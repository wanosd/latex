\chapter{Implementation and Testing}
\label{impltesting}

\section{Implemention}
\subsection{Implmention of the Spring Framework}
In order to begin implementation with the Spring MVC framework, there are a number of configuration files that are necessary. The core file is the \textit{web.xml} file. This file is reponsible for the configuration for the framework. One of the key responsibilities is the definition of the context xml files, whose purpose will be elaborated on later. Different development profiles can be configured within this file in order to produce different development environments, such as production and testing environments.\newline 

\begin{table}[H]
\begin{lstlisting}
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>
	classpath:beans/dao-context.xml
	classpath:beans/service-context.xml
	classpath:beans/security-context.xml
</param-value>
 </context-param>
\end{lstlisting}
\caption{Spring Context File Defintion}
\end{table}

Of particular importance are the definition of the context parameters. In this project, there were three main context files. These files are important, as they are the foundation for Springs dependency injection facilities. Dependency Injection is a software design pattern. It allows an application to be configured so that hard coded dependencies are removed and the necessary objects can be inserted during run time or at compile time. In Spring, this is done with the \textit{@Autowired} annotation. This instantiates a reference with a relevant bean, and removes having to use the \textit{new} keyword. \newline

\begin{itemize}
\item Data Access Object Context
\item Service Context
\item Security Context
\end{itemize}

The DAO Context file specifies the packages that contain the various DAO classes within the application. It also contains configurations for both the database connection details, and Hibernate configurations. Packages containing entity classes for Hibernate are specified within this context also. \newline

\begin{table}[H]
\begin{lstlisting}
<property name="hibernateProperties">
<props>
<prop key="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</prop>
</props>
</property>
\end{lstlisting}
\caption{DAO Context Configuration}
\end{table}

The Service Context file is responsible for specifying the base package containing the Service classes necessary to facilitate the collaboration between the Controller classes and the DAO classes. This file specifies that annotations will be used to configure the Service classes.\newline

\begin{table}[H]
\begin{lstlisting}
<context:annotation-config></context:annotation-config>
<context:component-scan base-package="service"></context:component-scan>
\end{lstlisting}
\caption{Service Context Configuration}
\end{table}

The Security Context file is the larger of the three files, and is responsible for the security configuration of the web application. There are four main areas within the file that were used to configure the web application created in this project. \newline The User Service aspect of the configuration file is responsible for retrieving users and their authority within the scope of the web application. \newline The URL access configuration ensures that only users who are authorised to access certain portions of the site are allowed access. \newline The Security Annotations allow the creation of an extra level of security into an application. At class level, annotations can be placed on methods to further ensure that proper access is enforced throughout the application. \newline Lastly, the Security Context is responsible for creating the password encoder bean in which passwords are encoded, and decoded, upon account creation and login. This ensures that no passwords in plain text form are ever stored on either the server or the database within the web application. \newline

\begin{itemize}
\item User Service
\begin{lstlisting}
<security:authentication-manager>	
	<security:authentication-provider>
	<security:jdbc-user-service data-source-ref="dataSource"
		id="jdbcUserService" authorities-by-username-query="select username, authority from users where binary username = ?" />
	<security:password-encoder ref="passwordEncoder"></security:password-encoder>
	</security:authentication-provider>
</security:authentication-manager>
\end{lstlisting}
\item URL Access
\begin{lstlisting}
<security:intercept-url pattern="/timetable" access="permitAll"/>
<security:intercept-url pattern="/reportNoShow" access="permitAll"/>
<security:intercept-url pattern="/admin" access="hasRole('ROLE_ADMIN')"/>
<security:intercept-url pattern="/approveMembers" access="hasRole('ROLE_ADMIN')"/>
\end{lstlisting}
\item Security Annotation for Service Class
\begin{lstlisting}
<security:global-method-security secured-annotations="enabled"></security:global-method-security>
//Java Code from TimetableService class. 
//This code is invoked when booking a slot on the timetable and is only accessible by registered members.
@Secured({"ROLE_ADMIN", "ROLE_MEMBER", "ROLE_COMMITTEE", "ROLE_WARNING", "ROLE_SUSPEND"})
	public void update(Timetable t){
		timetableDAO.updateTimetable(t);
	}
\end{lstlisting}
\item Password Encoding
\begin{lstlisting}
<bean id="passwordEncoder"
class="org.springframework.security.crypto.password.StandardPasswordEncoder">
</bean>
\end{lstlisting}
\end{itemize}

\subsection{Security Specification within Spring MVC}

A core part of the Spring platform is the Security support. Security is an important aspect for any application, but more-so for one that stores user data, particularly sensitive data such as names, addresses, phone numbers, and payment details. While there is no payment infrastructure within this application, there is scope for a system to be implemented, and it could certainly be a future requirement. 

Spring handles security a number of ways. Firstly, it uses an \textit{authority} hierarchy to separate different levels of users. For this web application, there were three main levels of authority, with one level containing three different branches.
\begin{table}[H]
\begin{itemize}
\item ROLE ADMIN
\begin{itemize}
\item This refers to the main administration group. The group retains full rights across the web application
\end{itemize}
\item ROLE COMMITTEE
\begin{itemize}
\item This refers to the committee, as defined by the club themselves. This group with have the ability to perform some administrator privileges, but only those directly related to club activities, not site activities.
\end{itemize}
\item ROLE MEMBER
\begin{itemize}
\item The default user state. This group can perform actions such as booking slots in a timetable, registering for a tournament, and will have access to parts of the site unavailable to non-registered users.
\end{itemize}
\item ROLE WARNING 
\begin{itemize}
\item A restriction placed upon a member. For example, a member who books time slots, but does not attend.
\end{itemize}
\item ROLE SUSPEND
\begin{itemize}
\item A further restriction placed upon a member.
\end{itemize}
\end{itemize}
\caption{Security Roles within the Web Application}
\end{table}

To ensure that the correct user is logged in, the framework provides a SecurityContextHolder class which can be used by the Controllers in order to ensure that that any actions performed by the system are attributed to the correct user. In this regard, it was important that the system ensures that the duplication of a user-name is restricted. In this project, the user table had two keys: an integer id, which was the primary key, and the user-name was an email address. The validity of the email address was enforced at class level with the use on annotations on the user-name attribute within the User class. \newline

\begin{lstlisting}
//Excerpt from the User class
@NotNull(groups={PersistenceValidationGroup.class, FormValidationGroup.class})
@Pattern(regexp=".+\\@.+\\..+", message="This does not appear to be a valid email address", groups={PersistenceValidationGroup.class, FormValidationGroup.class})
@Column(name="username")
String username;
\end{lstlisting}

Another aspect of the Spring Security platform was Form Validation. When registering a user, there are a number a validation constraints that are placed upon the User class. Spring provides a facility to ensure these constraints are enforced, and to also provide a positive user experience. It does this through the use of a BindingResult object. This object holds a record of any errors from the form that the user populates. The controller that deals with the form will check the BindResult object for errors, and can respond appropriately. In order for this to work, both the Controller and the form need to be defined clearly. The form needs to be creating using the Spring Framework form tag library, and errors needs to be specified for each input within the form. These inputs, when used with Hibernate, all need to match with the attribute names given in the class they represent. This example references the User class. \pagebreak
\begin{table}[H]
\begin{lstlisting}
<!-- Excerpt from the User registration form. Formatting removed for clarity --!>
<sf:form id="details" method="post" action="${pageContext.request.contextPath}/register" commandName="member">
Name<<sf:input name = "name" path="name" type="text"/>
<sf:errors path="name" cssClass="error"></sf:errors>
Password<sf:input id="password" name = "password" path="password" type="password"/>
<sf:errors path="password" cssClass="error"></sf:errors>
</sf:form>

//Method from the MembersController class
//This method is responsible for validating the form that users complete to register.
@RequestMapping(value = "/register", method = RequestMethod.POST)
public String doRegister(Model model,
@Validated(FormValidationGroup.class) @ModelAttribute("member") User member, BindingResult result) {
if (result.hasErrors()) {
	return "createmembers"; // if the result has errors, go back to create page
}
if (userService.exists(member.getUsername())) {
	result.rejectValue("username", "Duplicate Key",
	"This email address has already been used");
	return "createmembers";
	//if the email address already exists, return with this message.
}
	else {
		try {
			member.setAuthority("ROLE_MEMBER");
			userService.create(member);
			return "registerSuccess";
			//successful creation of member
			} catch (Exception e) {
				return "error";
			}
		}
}
\end{lstlisting}
\caption{User Registration Form}
\end{table}

The UserDAO class then encodes the password using the already configured Password Encoder bean prior to saving it to the database. It was this process that introduced an issue with the validation process. When defining the constraints placed upon the password attribute within the User class, the encoding of the password at a later stage was not taken into account. When encoded, the length of the password increased well beyond the scope of the initial constraint. When Hibernate attempted to persist the User object, it found that the password was now in violation of the constraints placed upon this attribute within the User class. This issue did not occur in the application when using a JDBC database, and is a result of the close links that Hibernate has with its entity classes. In order to resolve this issue, Validation Groups were introduced. A Validation Group is a mechanism in which a class is used to define the validity of attributes within a class. Using these groups, the web application can enforce validation on attributes depending on the validation group specified in the Controller. As respects the application developed for this project, the constraint for the password only had to be enforced within the scope of the form. Once the form validation had passed, enforcement of the constraint was not a concern. By using a separate group for Hibernate persistence, the issue was resolved. (This needs revising! Bit wobbly and lacks structure, also previous code excerpt shows this in action also. Move up to there?)

The Security Context XML file is key to maintaining the integrity of the application security. This file defines access rights to the URL mappings within the application, and also enforces security for the service class methods. By default, the configuration denies access to all parts of the application, and access rights must be explicitly stated. This system relies on the developers to ensure that proper testing is completed to ensure that all access works as designed. This is a better solution than allowing access to all the site and restricting certain parts, such as the administrator panel, however. \newline

\begin{lstlisting}
<security:http use-expressions="true">
	<security:intercept-url pattern="/static/**" access="permitAll" />
	<security:intercept-url pattern="/images/**" access="permitAll" />
	<security:intercept-url pattern="/createmembers" access="permitAll" />
	<security:intercept-url pattern="/approveMembers" access="hasRole('ROLE_ADMIN')" />
	<security:intercept-url pattern="/tournamentRegister" access="isAuthenticated()" />
</security:http>
\end{lstlisting}

This code fragment from the \textit{Security-Context.xml} file displays how access for the web application is configured. While there are five roles within the system, it is not necessary to explicitly define what actions a role can perform. For example, all registered users should be able to register for an existing tournament. In this case, once the framework detects that a user is authenticated, that is sufficient to allow access to that part of the application. Other examples are the display of static images, such as banners and advertising. These should be visible to all visitors to the site, regardless of their authentication status. Accordingly, this area of the application is set to permitAll allowing such access.

\subsection{Maven Integration with Spring Tool Suite}

Maven was used within the scope of this project to manage the dependencies required by the web application. Maven came pre-installed and configured within the Spring Tool Suite IDE. Dependency Management can be handled one of two ways. Dependencies can be added using the GUI interface provided by an IDE, in this case, Spring Tool Suite. This GUI links to the repository located at http://mvnrepository.com/, and the user searches for the required files. Otherwise, the \textit{pom.xml} file may be edited to define dependencies manually. Below is an example of the Apache Tiles v3.0.3 dependency.

\begin{table}[H]
\begin{lstlisting}
<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-core</artifactId>
	<version>3.0.3</version>
</dependency>
\end{lstlisting}
\caption{Dependency XML Structure for Maven}
\end{table}

Maven also provided the archetype, or structure, for the application. It defined the folder structure for both the production and tests environments. It also sets up JUnit within the project.

\subsection{Hibernate Configuration}

Hibernate requires a SessionFactory object in order to connect to the database. Spring provides a class in order to facilitate this requirement, AnnotationSessionFactoryBean. This bean must be defined and configured within the \textit{DAO-Context.xml} file explained previously. 

\begin{table}[H]
\begin{lstlisting}
<bean id="sessionFactory"
class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean">
<property name="dataSource" ref="dataSource"></property>
<property name="hibernateProperties">
	<props>
		<prop key="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</prop>
	</props>
</property>
<property name="packagesToScan">
	<list>
		...
	</list>
</property>
</bean>
\end{lstlisting}
\caption{Hibernate SessionFactory Configuration}
\end{table}

Once the SessionFactory is configured, it needs to be called from within the DAO classes in the web application. In this web application, the SessionFactoryBean was derived from the AnnotationSessionFactoryBean class, and needed to be configured via annotations. The annotation used in the DAO classes is \textit{@Autowired}. This allows the object to be set using Springs dependency injection facilities.

\begin{table}[H]
\begin{lstlisting}
@Autowired
private SessionFactory sessionFactory;

public Session session(){
	logger.info("Session Factory returning current session.....");
	return sessionFactory.getCurrentSession();
}
\end{lstlisting}
\caption{Declarion of SessionFactory in DAO Class}
\end{table}

Once this SessionFactory object is configured within the DAO class, it can be used to perform queries on the database. There are four operations that this application is concerned with: \textit{Create}, \textit{Read}, \textit{Update} and \textit{Delete}, commonly known as CRUD. As discussed earlier, Hibernate is an Object Relational Mapping persistence solution. In order to ensure the correct mapping of classes to database schema, some preparatory work needs to be undertaken upon the entity classes.

\subsection{Class Configuration}

When defining the class, it is necessary to do one of two things with the class attributes. The attribute names much match both the type and name of the database schema, or they attributes must be annotated with the column name within the same schema. The number of attributes within a class must also not be less than the number of attributes on the database table. If an attribute is an auto-incrementing primary key, it needs to be stated within the class. It is also important to define getters and setters for each attribute, as these will be called by Hibernate without the application having to explicitly use them. 

\begin{table}[H]
\begin{lstlisting}
@Component
@Entity
@Table(name="users")
public class User {
	@Id
	@GeneratedValue
	int id;
	
	@NotNull(groups={PersistenceValidationGroup.class, FormValidationGroup.class})
	@Pattern(regexp=".+\\@.+\\..+", message="This does not appear to be a valid email address", groups={PersistenceValidationGroup.class, FormValidationGroup.class})
	@Column(name="username")
	String username;
	
	@Size(min=5, max=45, message="Named must be between 5 and 45 characters",groups={PersistenceValidationGroup.class, FormValidationGroup.class})
	@Column(name="name")
	String name;
	
	@Column(name="password")
	@Size(min=5, max=15, message="Password must be between 5 and 15 characters", groups=FormValidationGroup.class)
	String password;
	
	// rest of class truncated, getters and setters defined
\end{lstlisting}
\caption{Hibernate Entity Class Configuration}
\end{table}
	
Once the entity classes are configured correction, the SessionFactory object can be used to perform the CRUD operations upon the database.
	
\subsubsection{Create}

In order to create an entry in the database, an object is passed to the save() method within the SessionFactory object. Due to the mapping defined within the entity class, there is no need to specify parameters.

\begin{table}[H]
\begin{lstlisting}
public void createNewEvent(I_Event e){
	logger.info("Creating new event....");
	session().save(e);
}
\end{lstlisting}
\caption{Hibernate Create}
\end{table}

\subsubsection{Read}

Hibernate can return an individual object, or a list of those objects, to the Service class. Restrictions can also be applied to retrieve objects based on certain values within the attributes. This is specified using Hibernate Query Language (HQL).

The below example shows how a list of all User objects would be returned to the Service layer. The criteria, such as table name and column names, are specified within the User class. 

\begin{table}[H]
\begin{lstlisting}
public List<User> getAllUsers() {
	logger.info("Selecting All Members....(Hibernate)");
	return session().createQuery("from User").list();
}
\end{lstlisting}
\caption{Hibernate Retrieve All Objects }
\end{table}

In order to retrieve a unique object, Hibernate provides a Criteria interface for representing a query against an entity class, as outlined below. This will throw an error if there is more than one unique result. 

\begin{table}[H]
\begin{lstlisting}
public User getUserByName(String name) {
	Criteria crit = session().createCriteria(User.class);
	crit.add(Restrictions.eq("name", name)); 
	User user = (User) crit.uniqueResult();
	return user;
	}
\end{lstlisting}
\caption{Hibernate Retrieve Specific Objects }
\end{table}

It is also possible to specify attributes within the SessionFactory query using HQL. 

\begin{table}[H]
\begin{lstlisting}
public List<User> getCommittee() {
	logger.info("Selecting All Admin Members....");
	return session().createQuery("from User where authority = 'ROLE_COMMITTEE'").list();
}
\end{lstlisting}
\caption{Hibernate Retrieve Subset Objects using HQL }
\end{table}

\subsubsection{Update}

Update operations are identical to Save operations in Hibernate. An object is passed to the SessionFactory update() method, and Hibernate will save any changes to the object in the database. Hibernate checks the indentifier of the object, and if the identifier does not exist, it will throw an exception. This can be circumvented by using the saveOrUpdate() method of the SessionFactory object. In the event that a record does not exist to update, Hibernate will persist that object as a new record.

\begin{table}[H]
\begin{lstlisting}
public void disableMember(String username) {
	Criteria crit = session().createCriteria(User.class);
	crit.add(Restrictions.eq("username", username)); // Restrictions.idEq for primary key integer
	User user = (User) crit.uniqueResult();
	user.setEnabled(false);
	session().update(user);
	logger.info("User Disabled");
	}
\end{lstlisting}
\caption{Hibernate Update Object }
\end{table}

\subsubsection{Delete}

Delete operations are implemented in a very similar fashion to Update queries. 

\begin{table}[H]
\begin{lstlisting}
public void deleteTournament(Tournament t){
	session().delete(t);
}
\end{lstlisting}
\caption{Hibernate Update Object }
\end{table}


\subsubsection{Comparison with JDBC Queries}

A considerable advantage of Hibernate over JDBC is the reduction in complexity in creating queries. Since Hibernate encapsulates the table structure of the database table within the entity class, there is no need to explicitly state column names within the query structure. This was made clear during the conversion from a JDBC database to a Hibernate one during the development of this project.

\begin{table}[H]
\begin{lstlisting}
@Transactional
public void createUser(User user) {
	user.setPassword(passwordEncoder.encode(user.getPassword()));
	user.setBookings_left(0);
	session().save(user);
}
\caption{Hibernate Create User Query }
\end{lstlisting}
\end{table}

The JDBC query for the above Hibernate query was much larger, and much more needed to be explicitly stated. While the configuration of the User class was not necessary for the JDBC connection, the risk of possible errors introduced by the length of the SQL query contain within, made it a very difficult solution to manage.

\begin{table}[H]
\begin{lstlisting}
@Transactional
public boolean createUserJDBC(User user) {
	MapSqlParameterSource params = new MapSqlParameterSource();
	params.addValue("username", user.getUsername());
	params.addValue("name", user.getName());
	params.addValue("password", passwordEncoder.encode(user.getPassword()));
	params.addValue("gender", user.getGender());
	params.addValue("member_type", user.getMember_type());
	params.addValue("grade", user.getGrade());
	params.addValue("ad_line1", user.getAd_line1());
	params.addValue("ad_line2", user.getAd_line2());
	params.addValue("ad_city", user.getAd_city());
	params.addValue("ad_county", user.getAd_county());
	params.addValue("contact_num", user.getContact_num());
	params.addValue("em_con_name", user.getEm_con_name());
	params.addValue("em_con_num", user.getEm_con_num());
	params.addValue("role", "ROLE_MEMBER");

	return jdbc.update("insert into users (username, password, name, gender, member_type, grade, ad_line1, ad_line2, ad_city, ad_county, 
	contact_num, em_con_name, em_con_num, enabled. authority) values (:username, :password, :name, :gender, :member_type, :grade, 
	:ad_line1, :ad_line1, :ad_city, :ad_county, :contact_num, :em_con_name, :em_con_num, false, :role)",params) == 1;
}
\end{lstlisting}
\caption{JDBC Create User Query }
\end{table}

\subsubsection{Timetable Hibernate Structure}

One of the most difficult features to implement within the application was the Timetable. While the goal was to create a timetable suitable for Monaleen GAA Tennis Club, it was desirable that the timetable retain the ability to have some dynamic features, not pre-set features that were not user definable. One issue this raised was how to handle a varying number of slots in each day. If a user could defined 10 slots a day, how would be store this in such a way that a user could also define a timetable with 20 slots a day. Hibernate was able to facilitate this design with considerably less input from a developer.

The solution implemented in this application was to use List objects to store the values for each day. There would be seven lists in the Timetable class, one for each day.

\begin{table}[H]
\begin{lstlisting}
@Entity
@Component
@Table(name = "timetable")
public class MonaleenTTV1 implements Timetable {
	@Id
	@GeneratedValue
	private int id;
	/**
	* Other Attributes Here
	**/
	
	@ElementCollection
	@CollectionTable (name = "monday", joinColumns=@JoinColumn(name="id"))
	private List<String> monday;
	
	@ElementCollection
	@CollectionTable (name = "tuesday", joinColumns=@JoinColumn(name="id"))
	private List<String> tuesday;
	
	@ElementCollection
	@CollectionTable (name = "wednesday", joinColumns=@JoinColumn(name="id"))
	private List<String> wednesday;
	
	@ElementCollection
	@CollectionTable (name = "thursday", joinColumns=@JoinColumn(name="id"))
	private List<String> thursday;
	
	@ElementCollection
	@CollectionTable (name = "friday", joinColumns=@JoinColumn(name="id"))
	private List<String> friday;
	
	@ElementCollection
	@CollectionTable (name = "saturday", joinColumns=@JoinColumn(name="id"))
	private List<String> saturday;
	
	@ElementCollection
	@CollectionTable (name = "sunday", joinColumns=@JoinColumn(name="id"))
	private List<String> sunday;
	
	//getters and setters
}
\end{lstlisting}
\caption{Timetable Class List Configuration}
\end{table}

This results in the Timetable object being made up of 8 database tables. The core of the class is stored in the 'Timetable' database table. This table contains the primary keys and all other attributes, such as name, number of slots, timetable series. The seven other tables each represent a collection within the Timetable class. Each of these tables has a non unique, foreign key that ties it back to the central table. For example, if we were to create a Timetable with 10 slots, with the primary key being 1, each of the collection tables would have 10 entries. Each of these entries would have an id of 1, to match the primary key in the core table, plus a value, such as 'Free Court'. The position in the table corresponds to the position within the collection class. 

The following example shows a Timetable configured with two slots. Upon creation, a series is created for each timetable. Each series contains 52 timetables, one for each week. The currently displayed timetable is determined by its position in the series in relation to the current week of the year, as shown by the Java Calendar class. The 'preview' attribute determines how far ahead the application will display the next number of timetables. In this example, the next three weeks of timetables are available for viewing and booking. This allows the administrator to dynamically restrict how far in advance users can book slots.

\begin{table}
    \begin{tabular}{| l | l | l | l | l | l | l | l | p{.8cm} |}
    \hline
    pid & name & slots & startTime & endTime & enabled & preview & series & total\\ \hline
    1 & Court One Week 1 & 2 & 8 & 22 & 1 & 3 & 1 & 52\\ \hline
	2 & Court One Week 2 & 2 & 8 & 22 & 0 & 3 & 1 & 52\\ \hline
	3 & Court One Week 3 & 2 & 8 & 22 & 0 & 3 & 1 & 52\\ \hline
	4 & Court One Week 4 & 2 & 8 & 22 & 0 & 3 & 1 & 52\\ \hline
    \end{tabular}
	\caption{Timetable Core Database Table}
\end{table}

\begin{table}
\begin {center}
    \begin{tabular}{| l | l | p{.8cm} |}
	\hline
	pid & monday \\ \hline
	1 & Free Court \\ \hline
	1 & Free Court \\ \hline
	2 & Tournament \\ \hline
	2 & Free Court \\ \hline
	3 & User Booking \\ \hline
	3 & Free Court \\ \hline
	4 & Training \\ \hline
	4 & Free Court \\ \hline
	\end{tabular}
	\end{center}
	\caption{Timetable Storage Table for Monday Collection}
\end{table}

\subsection{Apache Tiles Configuration and Implementation}

Apache Tiles is configured within the web application core XML file. There are two classes that the configuration is concerned with: TilesViewResolver and TileConfigurer. Both are declared as beans within the configuration file and automatically created when the application is launched. The TilesConfigurer object takes one parameter: a location of the template that the default tile, and its subsequent children, will use. \newline

\begin{table}[H]
\begin{lstlisting}
<bean id="tilesViewResolver"
	class="org.springframework.web.servlet.view.tiles2.TilesViewResolver">
</bean>

<bean id="tilesConfig"
	class="org.springframework.web.servlet.view.tiles2.TilesConfigurer">
	<property name="definitions">
	<list>
		<value>/WEB-INF/layout/default.xml</value>
	</list>
	</property>
</bean>
\end{lstlisting}
\caption{Apache Tiles Configuration}
\end{table}

The default tile consists of a number of sections identified by a specific tag. These tags correspond to values within the tile layout configuration file. Using a version of inheritance, these can be overwritten and replaced with other pages in order to change the content of a page, while maintaining cohesion across the design of the application. 

The following examples shows the implementation within the configuration file. The first section of code is the overall template. This specifies the default values that make up a JSP page within the application. The second segment of code is the the definition for the initial home page for the web application. By the inclusion of the \textit{extends="users.base"} within the definition tags, it is defining the index as a sub class of the users.base definition. Consequently, it is possible to override any of the attributes within the users.base definition. In this example, the title and content of the default page are being overridden with different values in order construct a more suitable page. The header, links and footer however remain the same, and will do so will all pages following this format.

\begin{table}[H]
\begin{lstlisting}
<definition name="users.base" template="/WEB-INF/templates/default.jsp">
	<put-attribute name="title" value="Monaleen Tennis Club - Default Template"></put-attribute>
	<put-attribute name="header" value="/WEB-INF/tiles/header.jsp"></put-attribute>
	<put-attribute name="links" value="/WEB-INF/tiles/links.jsp"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/content.jsp"></put-attribute>
	<put-attribute name="footer" value="/WEB-INF/tiles/footer.jsp"></put-attribute>
</definition>

<definition name="index" extends="users.base">
	<put-attribute name="title" value="Monaleen Tennis Club - Home Page"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/index.jsp"></put-attribute>
</definition>

<definition name="admin" extends="users.base">
	<put-attribute name="title" value="Monaleen Tennis Club - Admin"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/admin.jsp"></put-attribute>
</definition>
\end{lstlisting}
\caption{Apache Tiles Configuration}
\end{table}

\subsection{Services}

In this application, Services are the layers between the Controllers and the DAO classes and enable communication between the two sets of objects. This allows us to encapsulate the logic of what a service needs to do within a set of classes, rather than allowing the Controllers to access to DAO directly. Any changes required to the DAO need only be changed in the Service classes, allowing the Controllers to remain unchanged. 

\subsection{Logging Implementation and Configuration}

The logging for this application was provided by \textit{log4j.} Logging became very useful for tracking down, and isolating bugs, throughout the application. Since there were a considerable number of dependencies and different technologies working together, it rapidly became very difficult to see where errors originated from. Stack-traces quickly became unmanageable. \textit{Log4j} works by allowing the developer to view a number of logs of varying types within the application.
\begin{table}[H]
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Log Type & Description \\ \hline
    INFO & Messages that highlight the progress of the application at coarse-grained level  \\ \hline
    DEBUG & Fine-grained informational events that are most useful to debug an application\\ \hline
	TRACE & Finer-grained informational events than the DEBUG\\ \hline
	WARN & Potentially harmful situations\\ \hline
	ERROR & Error events that might still allow the application to continue running\\ \hline
    FATAL & Very severe error events that will presumably lead the application to abort\\ \hline
    \end{tabular}
\end{center}
\caption{Log Types}
\end{table}

\textit{Log4j} is configured with a properties file that allows you to see the various levels of logs displays by the applications running. Implementation of a logging system resolved a number of Spring Security issues within the web application. Spring Security, concerned with access rights to mappings within the application, did not output failed access attempts to the console. This made it very difficult to debug. When configuring \textit{Log4j} to catch the logs created by the security components, the application became much easier to debug. The properties file for this web application is detailed below.

\begin{table}[H]
\begin{lstlisting}
log4j.rootLogger=INFO, CONSOLE
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.SimpleLayout
log4j.logger.org.hibernate.SQL=DEBUG
log4j.logger.org.hibernate.type=TRACE
log4j.logger.org.springframework.security=DEBUG
\end{lstlisting}
\caption{Log4j Configuration}
\end{table}

Logging can be implemented on a class by class basis. Within this application, it was used to display informational messages to the developer. These included items such as database access, objects being created and updated. In order to enable logging on a class, a logger must be instantiated with reference to the class that requires logging. The logger object then is called with a method corresponding to the type of log you wish to throw along with a message.

\begin{table}[H]
\begin{lstlisting}
private static Logger logger = Logger.getLogger(UserDAO.class);

public Session session(){ 
	logger.info("Session Factory returning current session.....");
	return sessionFactory.getCurrentSession();
}

public List<User> getUsers() {
	logger.info("Selecting All Enabled Members....");
	return session().createQuery("from User where enabled = '1'").list();
}

public User getUserByName(String name) {
	Criteria crit = session().createCriteria(User.class);
	crit.add(Restrictions.eq("name", name)); 
	try{
	User user = (User) crit.uniqueResult();
	}
	catch(Exception e){
	logger.error{"Must be unique result : Thrown from UserDAO.getUserByName(String name));
	}
	return user;
}
\end{lstlisting}
\caption{Logger Usage within UserDAO.class}
\end{table}


\subsection{JSTL Definition and Usage}

JSTL is used within the application to manage how information was displayed. It was preferred, during the development of the application, that all of the logic be handled at the Controller level, and that the JSP pages would resolve the models passed to it into the view seen by the user. It was not desirable for the pages to contain JSP directives, or to use the implicit objects contained within JSP pages. 

The main tags used within the application were the JSTL Core tags.  These tags allow the usage of conditional statements and the definition of parameters within the JSP page. In order to use this technology, the relevant jar must be made available in the build path or within the Maven dependencies of the project. The following statement must be included in all JSP pages that wish to make use of the tags also.\newline

\begin{lstlisting}
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
\end{lstlisting}

Within the application, the controller will create a model and pass it to the JSP page. The page uses the JSTL tags to manage and display relevant information from the model, and user actions based on the information contained within. The example below is taken from the Timetable display page from the application.\newline

\begin{table}[H]
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Model Name & Summary \\ \hline
    name & The username of the currently authenticated user  \\ \hline
    realName & The real name of the currently authenticated user\\ \hline
	bookings & The number of remaining bookings of the currently authenticated users\\ \hline
	date & The current week of the year and the current date. Calculated using separate method.\\ \hline
	next & The id number of the court following the current court, if applicable\\ \hline
    prev & The id number of the court preceding the current court, if applicable\\ \hline
	court & The current court, determined by the current week, provided by the java.util.Date class \\
    \hline
    \end{tabular}
\end{center}
\caption{Model Attributes}
\end{table}
\pagebreak
\begin{lstlisting}
@RequestMapping(value = "/gotoCourt", method = RequestMethod.POST)
public String chooseCourt(Model model, HttpServletRequest request) {
	//abbreviated method to display court, logic removed
	//highlighting the attributes within the model
	model = addDateToTimetable(model, id));
	model.addAttribute("series",timetableService.getById(id).getSeries());
	model.addAttribute("name", SecurityContextHolder.getContext().getAuthentication().getName());
	model.addAttribute("court", current);
	model.addAttribute("realname", name);
	model.addAttribute("bookings", left);
	if (seriesMatch(courtID, nextCourt)) {
		model.addAttribute("next", (current.getId() + 1));
	}
	if (seriesMatch(courtID, prevCourt)) {
		model.addAttribute("prev", (current.getId() - 1));
	}
	return "court";
}
\end{lstlisting}	

This example is an excerpt from the TimetableContoller class. The logic determining the values has been removed. This is to highlight how attributes are added to the model from within the controller. This is the information that the JSP page will have access to once it has been displayed.

The above code deals with the display of \textit{Monday} within the Timetable display page. In the \textit{c:forEach} tags, it loops through each value in the \textit{court.monday} list that has been passed to it by the controller. The size of this list is determined by the user when the timetable is created, and the number of slots per day is specified. If the current value being examined in the loop is equal to the value "Free Court", it will display a link to the Book Form mapping. This aspect of the Timetable Controller will check that a user has any remaining bookings left and respond as appropriate. In the event that the value in the list does not equal "Free Court", it will make a choice. If the currently authenticated user made the booking, it will display an option to remove their booking from the slot. Otherwise, it will give any other user an option to report the user as a "no show" should a user fail to show for a previously booked slot. \newline

\begin{table}[H]
\begin{lstlisting}
<c:forEach var="row" varStatus="loop" items="${court.monday}">
<c:choose>
<c:when test='${row eq "Free Court"}'><tr>
<td class="inner"><form action="${pageContext.request.contextPath}/bookCourt"
method="POST">
<input type="hidden" value="${loop.index}" name="position" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" />
<input type="submit" value="Book">
</form></td></tr>
</c:when>
<c:otherwise><tr><td class="inner">${row}
<c:choose>
<c:when test="${name eq pageContext['request'].userPrincipal.name && row eq realname }">
<form action="${pageContext.request.contextPath}/unbookCourt" method="POST">
<input type="hidden" value="${loop.index}" name="position" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" /> 
<input type="submit" value="Unbook">
</form></c:when>
<c:otherwise>
<form action="${pageContext.request.contextPath}/reportNoShow" method="POST">
<input type="hidden" value="${row}" name="bookedUser" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" /> 
<input type="submit" value="Report User">
</form></c:otherwise>
\end{lstlisting}
\caption{Code Showing Display of Timetable}
\end{table}

(another example maybe? Can show how JSTL used to hide null attributes within the models to ensure page looks well)
 
\subsection{Version Control Configuration and Usage}

The version control used for this project was GitHub. Spring Tool Suite came pre-installed with eGit, an open source Eclipse plug-in for GitHub. In order to configure Git, a repository must be created on the github.com website. Once created, the user imports that repository through the File/Import command within the IDE. A dialog box is presented to the user in order to specify the Uniform Resource Identifier (URI) of the github project. The URI for the application is \textit{https://github.com/wanosd/mts}. This was initiated as a private repository, meaning that a user-name and password needed to be specified in order for STS to clone the project. Projects that are public do not need this level of authorisation to clone a copy of the project, however a project may explicitly define who is allowed to make adjustments to a project, even if the project is open source.

The mechanics of github, having been explained in a previous section, are accessed through \textit{Team} menu, accessed by right clicking on the project within the Project Viewer pane. This allows the users to pull down the most recent version, or to commit a new version of the project to the repository for all to access. When performing a commit, each user within the repository will be able to see what files have changed, showing both additions and removals from the files. An optional summary message to describe the commit is also recommended. 

A feature that was also used within the scope of this project was the Replace With action. This allows a user to swap between commits in the event that they want to see older versions, or in this case, broke something and need to go back to an older version.

\subsection{External Code}

There are two aspects of external code being used within this web application. The first is the CSS file that the site is using. This was a free template obtained from \href{http://skylinestemplates.blogspot.ie/2011/11/greefies-solution-xhtml-and-css.html}{Skylines Templates}

This template was modified in order to fit in with certain aspects of the site, but the look, feel and images remain consistent with those of the template.

The other code used in this application that was not original is the Google Maps script, visible in the Contact Us page of the web application. This is provided at \href{https://developers.google.com/maps/documentation/javascript/examples/map-simple}{Google Maps Simple Map Example} and is available to use freely. The code was slightly modified to change both the GPS co-ordinates and the initial zoom level of the map. The page is included in the Contact Us tile.\newline

\begin{table}[H]
\begin{lstlisting}
//code to include maps.jsp in contactus.jsp
<div align="center"><%@include file="maps.jsp"%></div>

//code of the maps.jsp change with modified Google javascript
<script src="http://maps.googleapis.com/maps/api/js?sensor=false">
</script>
<script>
function initialize()
{
var mapProp = {
center:new google.maps.LatLng(52.6565176,-8.5537577),
zoom:18,
mapTypeId:google.maps.MapTypeId.ROADMAP
};
var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);
}
google.maps.event.addDomListener(window, 'load', initialize);
</script>

\end{lstlisting}
\caption{Code Showing Google Maps Integration}
\end{table}
\pagebreak

\section{Testing}

\subsection{JUnit Testing}

The primary method of testing was implemented using JUnit. A Test Suite of JUnit tests were prepared to test the key features of the application. A separate test database was constructed. It was important to ensure that the testing environment was using the same context files as the production environment. The test class had to be annotated to enforce this. While the context files were the same, the DataSource file has changed as a different database is being using in this environment.


\begin{table}[H]
\begin{lstlisting}
@ActiveProfiles("dev")
@ContextConfiguration(locations = { "file:src/main/java/beans/dao-context.xml",
"file:src/main/java/beans/security-context.xml",
"classpath:test/config/datasource.xml" })
@RunWith(SpringJUnit4ClassRunner.class)
public class HibernateTests {
	
	@Autowired
	private UserDAO userDAO;
	
	@Autowired
	private TournamentDAO tournamentDAO;
	
	@Autowired
	private DataSource dataSource;
	
	//Class truncated 
}

\end{lstlisting}
\caption{JUnit Test Example}
\end{table}

The database is then initialised to ensure the tests are being run against the same database, and that repeat tests are consistent.

\begin{table}[H]
\begin{lstlisting}
@Before
public void init(){
	JdbcTemplate jdbc = new JdbcTemplate(dataSource);
	jdbc.execute("delete from users"); 
}
\end{lstlisting}
\caption{JUnit @Before Test Configuration}
\end{table}

In these example tests, the UserDAO is being tested to ensure that it returns true when the exists() method is called on it. This is important within the scope of the application to ensure that primary keys are not duplicated. The method is annotated with \textit{@Test}. The methods \textit{assertTrue} and \textit{assertFalse} expect a return value of true and false respectively. They take two parameters: an error message and a boolean value, or a method that returns a boolean value. In the \textit{assertTrue} method below, the UserDAO will return true if the user exists. In the event that the user does not exist, it will fail the test and return the message "User should exist".\newline 

\begin{table}[H]
\begin{lstlisting}
@Test
public void testExists(){
	userDAO.createUser(user1);
	assertTrue("User should exist", userDAO.exists(user1.getUsername()));
	assertFalse("User should not exist", userDAO.exists("jkljfksakfjahghdsopjclkhfkjafhkjdshFHajhgouwe"));
}
\end{lstlisting}
\caption{JUnit UserDAO Exists() Test}
\end{table}

Another test with the UserDAO was to ensure that users were being saved correctly. In this example, users are being created and saved to the database. The method \textit{assertEquals} checks two interger values and returns an error message if they do not match.

\begin{table}[H]
\begin{lstlisting}
@Test 
public void testCreateRetrieve(){
	userDAO.createUser(user1);
	List<User> users1 = userDAO.getAllUsers();
	assertEquals("One user should have been created and retrieved", 1, users1.size());
	assertEquals("Inserted user should match retrieved", user1, users1.get(0));
	userDAO.createUser(user2);
	userDAO.createUser(user3);
	userDAO.createUser(user4);
	List<User> users2 = userDAO.getAllUsers();
	assertEquals("Number of users should be four", 4, users2.size());
}
\end{lstlisting}
\caption{JUnit Create and Size Test}
\end{table}



