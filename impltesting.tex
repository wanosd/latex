\chapter{Implementation and Testing}
\label{impltesting}

\section{Implemention}
\subsection{Spring}
In order to begin implementation with the Spring MVC framework, there are a number of configuration files that are necessary. The core file is the \textit{web.xml} file. This file is reponsible for the configuration for the framework. One of the key responsibilities is the definition of the context xml files, whose purpose will be elaborated on later. Different development profiles can be configured within this file in order to produce different development environments, such as production and testing environments.\newline 

\begin{table}[H]
\begin{lstlisting}
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>
	classpath:beans/dao-context.xml
	classpath:beans/service-context.xml
	classpath:beans/security-context.xml
</param-value>
 </context-param>
\end{lstlisting}
\caption{Spring Context File Defintion}
\end{table}

Of particular importance are the definition of the context parameters. In this project, there were three main context files.\newline

\begin{itemize}
\item Data Access Object Context
\item Service Context
\item Security Context
\end{itemize}

The DAO Context file specifies the packages that contain the various DAO classes within the application. It also contains configurations for both the database connection details, and Hibernate configurations. Packages containing entity classes for Hibernate are specified within this context also. \newline

\begin{table}[H]
\begin{lstlisting}
<property name="hibernateProperties">
<props>
<prop key="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</prop>
</props>
</property>
\end{lstlisting}
\caption{DAO Context Configuration}
\end{table}

The Service Context file is responsible for specifying the base package containing the Service classes necessary to facilitate the collaboration between the Controller classes and the DAO classes. This file specifies that annotations will be used to configure the Service classes.\newline

\begin{table}[H]
\begin{lstlisting}
<context:annotation-config></context:annotation-config>
<context:component-scan base-package="service"></context:component-scan>
\end{lstlisting}
\caption{Service Context Configuration}
\end{table}

The Security Context file is the larger of the three files, and is responsible for the security configuration of the web application. There are four main areas within the file that were used to configure the web application created in this project. \newline The User Service aspect of the configuration file is responsible for retrieving users and their authority within the scope of the web application. \newline The URL access configuration ensures that only users who are authorised to access certain portions of the site are allowed access. \newline The Security Annotations allow the creation of an extra level of security into an application. At class level, annotations can be placed on methods to further ensure that proper access is enforced throughout the application. \newline Lastly, the Security Context is responsible for creating the password encoder bean in which passwords are encoded, and decoded, upon account creation and login. This ensures that no passwords in plain text form are ever stored on either the server or the database within the web application. \newline

\begin{itemize}
\item User Service
\begin{lstlisting}
<security:authentication-manager>	
	<security:authentication-provider>
	<security:jdbc-user-service data-source-ref="dataSource"
		id="jdbcUserService" authorities-by-username-query="select username, authority from users where binary username = ?" />
	<security:password-encoder ref="passwordEncoder"></security:password-encoder>
	</security:authentication-provider>
</security:authentication-manager>
\end{lstlisting}
\item URL Access
\begin{lstlisting}
<security:intercept-url pattern="/timetable" access="permitAll"/>
<security:intercept-url pattern="/reportNoShow" access="permitAll"/>
<security:intercept-url pattern="/admin" access="hasRole('ROLE_ADMIN')"/>
<security:intercept-url pattern="/approveMembers" access="hasRole('ROLE_ADMIN')"/>
\end{lstlisting}
\item Security Annotation for Service Class
\begin{lstlisting}
<security:global-method-security secured-annotations="enabled"></security:global-method-security>
//Java Code from TimetableService class. 
//This code is invoked when booking a slot on the timetable and is only accessible by registered members.
@Secured({"ROLE_ADMIN", "ROLE_MEMBER", "ROLE_COMMITTEE", "ROLE_WARNING", "ROLE_SUSPEND"})
	public void update(Timetable t){
		timetableDAO.updateTimetable(t);
	}
\end{lstlisting}
\item Password Encoding
\begin{lstlisting}
<bean id="passwordEncoder"
class="org.springframework.security.crypto.password.StandardPasswordEncoder">
</bean>
\end{lstlisting}
\end{itemize}

\subsection{Security}

A core part of the Spring platform is the Security support. Security is an important aspect for any application, but more-so for one that stores user data, particularly sensitive data such as names, addresses, phone numbers, and payment details. While there is no payment infrastructure within this application, there is scope for a system to be implemented, and it could certainly be a future requirement. 

Spring handles security a number of ways. Firstly, it uses an \textit{authority} hierarchy to separate different levels of users. For this web application, there were three main levels of authority, with one level containing three different branches.
\begin{table}[H]
\begin{itemize}
\item ROLE ADMIN
\begin{itemize}
\item This refers to the main administration group. The group retains full rights across the web application
\end{itemize}
\item ROLE COMMITTEE
\begin{itemize}
\item This refers to the committee, as defined by the club themselves. This group with have the ability to perform some administrator privileges, but only those directly related to club activities, not site activities.
\end{itemize}
\item ROLE MEMBER
\begin{itemize}
\item The default user state. This group can perform actions such as booking slots in a timetable, registering for a tournament, and will have access to parts of the site unavailable to non-registered users.
\end{itemize}
\item ROLE WARNING 
\begin{itemize}
\item A restriction placed upon a member. For example, a member who books time slots, but does not attend.
\end{itemize}
\item ROLE SUSPEND
\begin{itemize}
\item A further restriction placed upon a member.
\end{itemize}
\end{itemize}
\caption{Security Roles within the Web Application}
\end{table}

To ensure that the correct user is logged in, the framework provides a SecurityContextHolder class which can be used by the Controllers in order to ensure that that any actions performed by the system are attributed to the correct user. In this regard, it was important that the system ensures that the duplication of a user-name is restricted. In this project, the user table had two keys: an integer id, which was the primary key, and the user-name was an email address. The validity of the email address was enforced at class level with the use on annotations on the user-name attribute within the User class. \newline

\begin{lstlisting}
//Excerpt from the User class
@NotNull(groups={PersistenceValidationGroup.class, FormValidationGroup.class})
@Pattern(regexp=".+\\@.+\\..+", message="This does not appear to be a valid email address", groups={PersistenceValidationGroup.class, FormValidationGroup.class})
@Column(name="username")
String username;
\end{lstlisting}

Another aspect of the Spring Security platform was Form Validation. When registering a user, there are a number a validation constraints that are placed upon the User class. Spring provides a facility to ensure these constraints are enforced, and to also provide a positive user experience. It does this through the use of a BindingResult object. This object holds a record of any errors from the form that the user populates. The controller that deals with the form will check the BindResult object for errors, and can respond appropriately. In order for this to work, both the Controller and the form need to be defined clearly. The form needs to be creating using the Spring Framework form tag library, and errors needs to be specified for each input within the form. These inputs, when used with Hibernate, all need to match with the attribute names given in the class they represent. This example references the User class. \pagebreak

\begin{lstlisting}
<!-- Excerpt from the User registration form. Formatting removed for clarity --!>
<sf:form id="details" method="post" action="${pageContext.request.contextPath}/register" commandName="member">
Name<<sf:input name = "name" path="name" type="text"/>
<sf:errors path="name" cssClass="error"></sf:errors>
Password<sf:input id="password" name = "password" path="password" type="password"/>
<sf:errors path="password" cssClass="error"></sf:errors>
</sf:form>

//Method from the MembersController class
//This method is responsible for validating the form that users complete to register.
@RequestMapping(value = "/register", method = RequestMethod.POST)
public String doRegister(Model model,
@Validated(FormValidationGroup.class) @ModelAttribute("member") User member, BindingResult result) {
if (result.hasErrors()) {
	return "createmembers"; // if the result has errors, go back to create page
}
if (userService.exists(member.getUsername())) {
	result.rejectValue("username", "Duplicate Key",
	"This email address has already been used");
	return "createmembers";
	//if the email address already exists, return with this message.
}
	else {
		try {
			member.setAuthority("ROLE_MEMBER");
			userService.create(member);
			return "registerSuccess";
			//successful creation of member
			} catch (Exception e) {
				return "error";
			}
		}
}
\end{lstlisting}

The UserDAO class then encodes the password using the already configured Password Encoder bean prior to saving it to the database. It was this process that introduced an issue with the validation process. When defining the constraints placed upon the password attribute within the User class, the encoding of the password at a later stage was not taken into account. When encoded, the length of the password increased well beyond the scope of the initial constraint. When Hibernate attempted to persist the User object, it found that the password was now in violation of the constraints placed upon this attribute within the User class. This issue did not occur in the application when using a JDBC database, and is a result of the close links that Hibernate has with its entity classes. In order to resolve this issue, Validation Groups were introduced. A Validation Group is a mechanism in which a class is used to define the validity of attributes within a class. Using these groups, the web application can enforce validation on attributes depending on the validation group specified in the Controller. As respects the application developed for this project, the constraint for the password only had to be enforced within the scope of the form. Once the form validation had passed, enforcement of the constraint was not a concern. By using a separate group for Hibernate persistence, the issue was resolved. (This needs revising! Bit wobbly and lacks structure, also previous code excerpt shows this in action also. Move up to there?)

The Security Context XML file is key to maintaining the integrity of the application security. This file defines access rights to the URL mappings within the application, and also enforces security for the service class methods. By default, the configuration denies access to all parts of the application, and access rights must be explicitly stated. This system relies on the developers to ensure that proper testing is completed to ensure that all access works as designed. This is a better solution than allowing access to all the site and restricting certain parts, such as the administrator panel, however. \newline

\begin{lstlisting}
<security:http use-expressions="true">
	<security:intercept-url pattern="/static/**" access="permitAll" />
	<security:intercept-url pattern="/images/**" access="permitAll" />
	<security:intercept-url pattern="/createmembers" access="permitAll" />
	<security:intercept-url pattern="/approveMembers" access="hasRole('ROLE_ADMIN')" />
	<security:intercept-url pattern="/tournamentRegister" access="isAuthenticated()" />
</security:http>
\end{lstlisting}

This code fragment from the \textit{Security-Context.xml} file displays how access for the web application is configured. While there are five roles within the system, it is not necessary to explicitly define what actions a role can perform. For example, all registered users should be able to register for an existing tournament. In this case, once the framework detects that a user is authenticated, that is sufficient to allow access to that part of the application. Other examples are the display of static images, such as banners and advertising. These should be visible to all visitors to the site, regardless of their authentication status. Accordingly, this area of the application is set to permitAll allowing such access.

\subsection{Maven}

Maven was used within the scope of this project to manage the dependencies required by the web application. Maven came preinstalled and configured within the Spring Tool Suite IDE. Dependency Management can be handled one of two ways. Dependencies can be added using the GUI interface provided by an IDE, in this case, Spring Tool Suite. This GUI links to the repository located at http://mvnrepository.com/, and the user searches for the required files. Otherwise, the \textit{pom.xml} file may be edited manually. 

\begin{table}[H]
\begin{lstlisting}
<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-core</artifactId>
	<version>3.0.3</version>
</dependency>
\end{lstlisting}
\caption{Dependency XML Structure for Maven}
\end{table}

\subsection{Hibernate}

\subsection{Apache Tiles}

Apache Tiles is configured within the web application core xml file. There are two classes that the configuration is concerned with: TilesViewResolver and TileConfigurer. Both are declared as beans within the configuration file and automatically created when the application is launched. The TilesConfigurer object takes one parameter: a location of the template that the default tile, and its subsequent children, will use. \newline

\begin{lstlisting}

<bean id="tilesViewResolver"
	class="org.springframework.web.servlet.view.tiles2.TilesViewResolver">
</bean>

<bean id="tilesConfig"
	class="org.springframework.web.servlet.view.tiles2.TilesConfigurer">
	<property name="definitions">
	<list>
		<value>/WEB-INF/layout/default.xml</value>
	</list>
	</property>
</bean>
\end{lstlisting}

The default tile consists of a number of sections identified by a specific tag. These tags correspond to values within the tile layout configuration file. Using a version of inheritance, these can be overwritten and replaced with other pages in order to change the content of a page, while maintaining cohesion across the design of the application. 

The following examples shows the implementation within the configuration file. The first section of code is the overall template. This specifies the default values that make up a JSP page within the application. The second segment of code is the the definition for the initial home page for the web application. By the inclusion of the \textit{extends="users.base"} within the definition tags, it is defining the index as a sub class of the users.base definition. Consequently, it is possible to override any of the attributes within the users.base definition. In this example, the title and content of the default page are being overridden with different values in order construct a more suitable page. The header, links and footer however remain the same, and will do so will all pages following this format.

\begin{lstlisting}

<definition name="users.base" template="/WEB-INF/templates/default.jsp">
	<put-attribute name="title" value="Monaleen Tennis Club - Default Template"></put-attribute>
	<put-attribute name="header" value="/WEB-INF/tiles/header.jsp"></put-attribute>
	<put-attribute name="links" value="/WEB-INF/tiles/links.jsp"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/content.jsp"></put-attribute>
	<put-attribute name="footer" value="/WEB-INF/tiles/footer.jsp"></put-attribute>
</definition>

<definition name="index" extends="users.base">
	<put-attribute name="title" value="Monaleen Tennis Club - Home Page"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/index.jsp"></put-attribute>
</definition>

<definition name="admin" extends="users.base">
	<put-attribute name="title" value="Monaleen Tennis Club - Admin"></put-attribute>
	<put-attribute name="content" value="/WEB-INF/tiles/admin.jsp"></put-attribute>
</definition>

\end{lstlisting}

\subsection{Services}

\subsection{Logging}

\subsection{JSP Standard Tag Libraries}

JSTL was use within the application to manage how information was displayed. It was preferred, during the development of the application, that all of the logic be handled at the Controller level, and that the JSP pages would resolve the models passed to it into the view seen by the user. It was not desirable for the pages to contain JSP directives, or to use the implicit objects contained within JSP pages. 

The main tags used within the application were the JSTL Core tags.  These tags allow the usage of conditional statements and the definition of parameters within the JSP page. In order to use this technology, the relevant jar must be made available in the build path or within the Maven dependencies of the project. The following statement must be included in all JSP pages that wish to make use of the tags also.\newline

\begin{lstlisting}
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
\end{lstlisting}

Within the application, the controller will create a model and pass it to the JSP page. The page uses the JSTL tags to manage and display relevant information from the model, and user actions based on the information contained within. The example below is taken from the Timetable display page from the application.\newline

\begin{table}[H]
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
    Model Name & Summary \\ \hline
    name & The username of the currently authenticated user  \\ \hline
    realName & The real name of the currently authenticated user\\ \hline
	bookings & The number of remaining bookings of the currently authenticated users\\ \hline
	date & The current week of the year and the current date. Calculated using separate method.\\ \hline
	next & The id number of the court following the current court, if applicable\\ \hline
    prev & The id number of the court preceding the current court, if applicable\\ \hline
	court & The current court, determined by the current week, provided by the java.util.Date class \\
    \hline
    \end{tabular}
\end{center}
\caption{Model Attributes}
\end{table}
\pagebreak
\begin{lstlisting}
@RequestMapping(value = "/gotoCourt", method = RequestMethod.POST)
public String chooseCourt(Model model, HttpServletRequest request) {
	//abbreviated method to display court, logic removed
	//highlighting the attributes within the model
	model = addDateToTimetable(model, id));
	model.addAttribute("series",timetableService.getById(id).getSeries());
	model.addAttribute("name", SecurityContextHolder.getContext().getAuthentication().getName());
	model.addAttribute("court", current);
	model.addAttribute("realname", name);
	model.addAttribute("bookings", left);
	if (seriesMatch(courtID, nextCourt)) {
		model.addAttribute("next", (current.getId() + 1));
	}
	if (seriesMatch(courtID, prevCourt)) {
		model.addAttribute("prev", (current.getId() - 1));
	}
	return "court";
}
\end{lstlisting}	

This example is an excerpt from the TimetableContoller class. The logic determining the values has been removed. This is to highlight how attributes are added to the model from within the controller. This is the information that the JSP page will have access to once it has been displayed.

The above code deals with the display of \textit{Monday} within the Timetable display page. In the \textit{c:forEach} tags, it loops through each value in the \textit{court.monday} list that has been passed to it by the controller. The size of this list is determined by the user when the timetable is created, and the number of slots per day is specified. If the current value being examined in the loop is equal to the value "Free Court", it will display a link to the Book Form mapping. This aspect of the Timetable Controller will check that a user has any remaining bookings left and respond as appropriate. In the event that the value in the list does not equal "Free Court", it will make a choice. If the currently authenticated user made the booking, it will display an option to remove their booking from the slot. Otherwise, it will give any other user an option to report the user as a "no show" should a user fail to show for a previously booked slot. \newline

\begin{table}[H]
\begin{lstlisting}
<c:forEach var="row" varStatus="loop" items="${court.monday}">
<c:choose>
<c:when test='${row eq "Free Court"}'><tr>
<td class="inner"><form action="${pageContext.request.contextPath}/bookCourt"
method="POST">
<input type="hidden" value="${loop.index}" name="position" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" />
<input type="submit" value="Book">
</form></td></tr>
</c:when>
<c:otherwise><tr><td class="inner">${row}
<c:choose>
<c:when test="${name eq pageContext['request'].userPrincipal.name && row eq realname }">
<form action="${pageContext.request.contextPath}/unbookCourt" method="POST">
<input type="hidden" value="${loop.index}" name="position" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" /> 
<input type="submit" value="Unbook">
</form></c:when>
<c:otherwise>
<form action="${pageContext.request.contextPath}/reportNoShow" method="POST">
<input type="hidden" value="${row}" name="bookedUser" />
<input type="hidden" value="monday" name="day" /> 
<input type="hidden" value="${court.id }" name="ttid" /> 
<input type="submit" value="Report User">
</form></c:otherwise>
\end{lstlisting}
\caption{Code Showing Display of Timetable}
\end{table}

(another example maybe? Can show how JSTL used to hide null attributes within the models to ensure page looks well)
 

\subsection{External Code}

There are two aspects of external code being used within this web application. The first is the CSS file that the site is using. This was a free template obtained from \href{http://skylinestemplates.blogspot.ie/2011/11/greefies-solution-xhtml-and-css.html}{Skylines Templates}

This template was modified in order to fit in with certain aspects of the site, but the look, feel and images remain consistent with those of the template.

The other code used in this application that was not original is the Google Maps script, visible in the Contact Us page of the web application. This is provided at \href{https://developers.google.com/maps/documentation/javascript/examples/map-simple}{Google Maps Simple Map Example} and is available to use freely. The code was slightly modified to change both the GPS co-ordinates and the initial zoom level of the map. The page is included in the Contact Us tile.
\begin{table}[H]
\begin{lstlisting}
//code to include maps.jsp in contactus.jsp
<div align="center"><%@include file="maps.jsp"%></div>

//code of the maps.jsp change with modified Google javascript
<script src="http://maps.googleapis.com/maps/api/js?sensor=false">
</script>
<script>
function initialize()
{
var mapProp = {
center:new google.maps.LatLng(52.6565176,-8.5537577),
zoom:18,
mapTypeId:google.maps.MapTypeId.ROADMAP
};
var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);
}
google.maps.event.addDomListener(window, 'load', initialize);
</script>

\end{lstlisting}
\caption{Code Showing Google Maps Integration}
\end{table}

Should show




