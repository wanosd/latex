\chapter{Evaluation}
\label{evaluation}

(Evaluation as relates to architectural quality?)

\section{Security}
(Owasp Top 10?)

Injection - prevented by the user of named parameters within both JDBC and Hibernate code.

Broken Auth - Provided by the framework, 

XSS - 

Security Misconfiguration - Ensuring roles are defined clearly, and that security context is correct

Sensitive Data Exposure - password encoding performed, password is never saved in database, just the encoded version

Unvalidated Redirects - not used, ViewResolver performs all redirects. Invalid value passed to view will result in access denied error or a 404.


\section{Extensibility}

The goal of extensibility is "controlling the time and costs to implement, tests and deploy changes" \parencite{bass2003software}. The use of Hibernate in the architectural stack provides a measure of extensibility support for changes in entity classes. Any addition to an entity class would result in a change to a database schema. 

An application using Hibernate, in conjunction with Spring MVC, would need only to modify the View, illustrated in Figure~\ref{fig:viewChange}. This would need to be changed to facilitate input of the new attribute. Spring MVC uses spring form tags to map values to the object within the Controller, and the DAO layer persists the object. Since the object is configured with database mapping at class level, no changes are necessary to the DAO. The addition of Line 14 is Figure~\ref{fig:ViewChange} is the only changed needed to allow for the attribute to be modified within the application. The Controller, Service layer and DAO would remain unchanged.

\begin{table}[H]
\begin{lstlisting}
<sf:form id="details" method="post" action="${pageContext.request.contextPath}/adminProfileUpdate" commandName="member">
<table class="formtable">
Name:<sf:input name = "name" path="name" type="text"/>
Email:<sf:input name = "username" path="username" type="text"/>
Password:<sf:input name = "password" path="password" type="text"/>
Address Line 1<sf:input name = "ad_line1" path="ad_line1" type="text"/>
Address Line 2<sf:input name = "ad_line2" path="ad_line2" type="text"/>
City/Town<sf:input name = "ad_city" path="ad_city" type="text"/><br/>
County<sf:input name = "ad_county" path="ad_county" type="text"/><br/>
Contact Number<sf:input name = "contact_num" path="contact_num" type="text"/>
Emergency Contact Name<sf:input name = "em_con_name" path="em_con_name" type="text"/>
Emergency Contact Number<sf:input name = "em_con_num" path="em_con_num" type="text"/>
Role<sf:select path="authority"><sf:options items="${roles }"/></sf:select>
New Attribute<sf:input name = "new_attribute" path="new_attribute" type="text"/> //new line added
<input type="hidden" value="${member.username }" name="username"/>
<input value="Change Details" type="submit"/>
\end{lstlisting}
\caption{Change to view to support new attributes}
\label{fig:viewChange}
\end{table}
Using JDBC, again in partnership with Spring MVC, the View and the DAO object would need to be changed. Within the DAO, two actions must be performed, as depicted in Figure~\ref{fig:jdbcChanges}. Line 18 shows the addition of an extra parameter to map the value to a position in the SQL statement. The SQL statement must be modified also in order to correctly insert or update the persisted value in the database. This is shown in Lines 23 through 26, with the changes being shown in capital letters. 

\begin{lstlisting}
@Transactional
public boolean createUserJDBC(User user) {
MapSqlParameterSource params = new MapSqlParameterSource();
params.addValue("username", user.getUsername());
params.addValue("name", user.getName());
params.addValue("password", passwordEncoder.encode(user.getPassword()));
params.addValue("gender", user.getGender());
params.addValue("member_type", user.getMember_type());
params.addValue("grade", user.getGrade());
params.addValue("ad_line1", user.getAd_line1());
params.addValue("ad_line2", user.getAd_line2());
params.addValue("ad_city", user.getAd_city());
params.addValue("ad_county", user.getAd_county());
params.addValue("contact_num", user.getContact_num());
params.addValue("em_con_name", user.getEm_con_name());
params.addValue("em_con_num", user.getEm_con_num());
params.addValue("role", "ROLE_MEMBER");
params.addValue("NEW_ATTRIBUTE", "user.getNEW_ATTRIBUTE());
return jdbc
	.update("insert into users (username, name, password, gender, 
	member_type, grade, ad_line1, ad_line2, ad_city, ad_county,
	contact_num, em_con_name, em_con_num, enabled, authority,
	bookings_left, NEW_ATTRIBUTE) values (:username, :name, :password, 
	:gender, :member_type, :grade, :ad_line1, :ad_line1, 
	:ad_city, :ad_county, :contact_num,:em_con_name, :em_con_num,
	false, :role, 0, :NEW_ATTRIBUTE)",params) == 1;
	}
\end{lstlisting}
\begin{table}[H]
\caption{JDBC DAO changes with entity change}
\label{fig:jdbcChanges}
\end{table}

Hibernate provides better support for extensibility in this regard, allowing the developer to focus on database and view changes, with no need to modify the persistence layer between the application and the database.

\section{Usability and Performance}

The deliverable from this project was subjected to the same usability criteria as illustrated in Section~\ref{sec:usabilty}. The results are shown in Tables~\ref{fig:projecttable1} through~\ref{fig:projecttable5}. The overall results are compared in Figure~\ref{fig:projecttable6}.

\begin{table}[H]
\caption{Table 1 - Links}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
\textbf{Criteria} & \textbf{Project Application}\\ \hline
	Links are updated? & Yes\\ \hline
	Short-cuts for frequent users? & Yes\\ \hline
	Warning if link leads to large file? & n/a\\ \hline
	Indication of restricted access for link & Yes \\ \hline
	Link text indicates nature of target & Yes \\ \hline
	Total & 4/5 \\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable1}
\end{table}

\begin{table}[H]
\caption{Table 2 - Feedback Mechanisms}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
\textbf{Criteria} & \textbf{Project Application}\\ \hline
	Contact Details for website maintainer & Yes \\ \hline
	Link to page maintainer on each page & Yes \\ \hline
	Forms provided for users to enter details & Yes\\ \hline
	FAQ provided & Yes \\ \hline
	Feedback mechanisms are fully operational & Yes\\ \hline
	Total & 5/5 \\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable2}
\end{table}

\begin{table}[H]
\caption{Table 3 - Accessability}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
\textbf{Criteria} & \textbf{Project Application}\\ \hline
	Speed of site adequate& Yes\\ \hline
	Site Availability High? & Yes\\ \hline
	Website made known through search tools** & n/a \\ \hline
	Link back to parent entity & Yes\\ \hline	
	Name of entity reflected in URL & Yes \\ \hline	
	URL is not over complex,likely to be mistyped & Yes \\
	\hline	
	Total & 5/8\\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable3}
\end{table}


\begin{table}[H]
\caption{Table 4 - Design}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
\textbf{Criteria} & \textbf{Project Application}\\ \hline
	Format,Graphic Design Appropriate & Yes \\ \hline
	Pages appropriate length, clear, uncluttered& Yes \\ \hline
	Consistent format through website & Yes \\ \hline
	Site compatible with multiple browsers & Yes\\ \hline
	Site can be used without graphics & No\\ \hline
	Total & 4/5 \\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable4}
\end{table}

\begin{table}[H]
\caption{Table 5 - Navigability}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
	\textbf{Criteria} & \textbf{Project Application}\\ \hline
	Website organised by anticipated user need & Yes\\ \hline
	Navigation options are distinct& Yes \\ \hline
	Conventional navigation models*& Yes\\ \hline
	Navigation links are provided on all pages & Yes\\ \hline
	Browsing facilitated by menu or site map &Yes \\ \hline
	Reach any point in appropriate number of clicks** & Yes\\ \hline
	Search Engine Provided & No\\ \hline
	Total & 6/7 \\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable5}
\end{table}
\textit{*eg menu on top or left of screen}\newline
\textit{**defined as 3,} \cite{smith2001applying}

\begin{table}[H]
\caption{Table 6 - Overall Results}
\begin{center}
    \begin{tabular}{ | l | l | p{5cm} |}
    \hline
	Site & Total\\ \hline
	Monaleen Tennis Club & 14/30\\ \hline
	Tralee Tennis Club & 22.5/30\\ \hline
	Project Application & 24/30\\ \hline	
    \end{tabular}
\end{center}
\label{fig:projecttable6}
\end{table}

\section{Productivity}

\subsubsection{Hibernate}

One of the core technologies used within the application was Hibernate. One of the main benefits Hibernate provided to the project was simplifying the code in order to persist objects. When developing the application, the only concern was with objects as a whole, not on their individual attributes. With JDBC, there was a need to use SQL syntax within the application. In the case of the User class, there were 16 attributes which made the SQL INSERT statement for that class, shown in Figure~\ref{fig:jdbcsql}, difficult to read and troubleshoot.

\begin{figure}[H]
\begin{lstlisting}
@Transactional
public boolean createUserJDBC(User user) {
	MapSqlParameterSource params = new MapSqlParameterSource();
		//other params cut out to save space
		params.addValue("role", "ROLE_MEMBER");
		return jdbc
			.update("insert into users (username, name, password, gender, 
			member_type, grade, ad_line1, ad_line2, ad_city, ad_county,
			contact_num, em_con_name, em_con_num, enabled, authority,
			bookings_left) values (:username, :name, :password, 
			:gender, :member_type, :grade, :ad_line1, :ad_line1, 
			:ad_city, :ad_county, :contact_num,:em_con_name, :em_con_num,
			false, :role, 0)",params) == 1;
	}
\end{lstlisting}
\caption{JDBC SQL INSERT}
\label{fig:jdbcsql}
\end{figure}

However, it could be arguing by supplying a framework, such as Hibernate, to automate the creation of a query language that performance of an application could be affected. To examine this briefly, a small test was created. This this test, the application would use JDBC to create 10,000 records, update those records and then delete them. The application would then perform the same actions with the same data using Hibernate. The time taken to perform these tasks as a whole would be recorded in nanoseconds. The test is illustrated in Figure~\ref{fig:jdbcvhibernate} below.

\begin{figure}[H]
\begin{lstlisting}
@RequestMapping("/testdatabases")
public String testdatabases(Model model){
	User user = new User(); // create a new user
	long jStart = System.nanoTime();
	model.addAttribute("jdbcStart", jStart);
	for (int i = 0; i < 10000; i++){
		user.setUsername(i + "@test.ie");
		userService.createJDBC(user);
		userService.enableUserJDBC(user);
		userService.deleteUserJDBC(user);
	}
	model.addAttribute("jdbcFinish", (System.nanoTime() - jStart));
	
	long hStart = System.nanoTime();
	model.addAttribute("hibernateStart", hStart);
	for (int i = 0; i < 10000; i++){
		user.setUsername(i + "@test.ie");
		userService.create(user);
		user.setEnabled(true);
		userService.updateUser(user);
		userService.delete(user);
	}
	model.addAttribute("hibernateFinish", (System.nanoTime() - hStart));
	return "testdatabases";
}
\end{lstlisting}
\caption{JDBC Vs Hibernate Test}
\label{fig:jdbcvhibernate}
\end{figure}

The results are displayed in Table~\ref{fig:resulttable} below. NS refers to NanoSeconds, and MM:SS refers to the total in minutes and seconds. The test was run three times and an average was created. The test machine was an Amazon EC-2 server, which was a 32-bit micro instance, with 650mb of RAM with one virtual CPU. This is running a modified version of Red Hat Enterprise Linux.

\begin{table}[H]
\caption{Hibernate Vs JDBC Results}
\begin{center}
    \begin{tabular}{ |l | l | l | l | p{2.5cm} |}
    \hline
     Run & Database & No Queries & Total (NS) & Total (MM:SS)\\ \hline
	 1 & Hibernate & 10,000 &198469890740&03:20\\ \hline
	 1 & JDBC & 10,000 &211883464327&03:30\\ \hline
	 2 & Hibernate & 10,000 &188055485374&03:07\\ \hline
	 2 & JDBC & 10,000 &200521721809&03:22\\ \hline
	 3 & Hibernate & 10,000 &188423897510&03:06\\ \hline
	 3 & JDBC & 10,000 &193541735201&03:20\\ \hline
	Avg & Hibernate & 10,000 &191649757878 &03:12\\ \hline
	Avg & JDBC & 10,000 & 201982307112&03:21\\ \hline
    \end{tabular}
\end{center}
\label{fig:resulttable}
\end{table}

\begin{figure}[H]
\begin{lstlisting}
//Excepts from the UserDAO for Hibernate and JDBC actions
//Hibernate
return sessionFactory.getCurrentSession(); //return current session
user.setPassword(passwordEncoder.encode(user.getPassword()));
session().save(user);
session().update(user);	
session().delete(user);

//JDBC
MapSqlParameterSource params = new MapSqlParameterSource();//start create
params.addValue("username", user.getUsername());
params.addValue("name", user.getName());
params.addValue("password", passwordEncoder.encode(user.getPassword()));
params.addValue("gender", user.getGender());
params.addValue("member_type", user.getMember_type());
params.addValue("grade", user.getGrade());
params.addValue("ad_line1", user.getAd_line1());
params.addValue("ad_line2", user.getAd_line2());
params.addValue("ad_city", user.getAd_city());
params.addValue("ad_county", user.getAd_county());
params.addValue("contact_num", user.getContact_num());
params.addValue("em_con_name", user.getEm_con_name());
params.addValue("em_con_num", user.getEm_con_num());
params.addValue("role", "ROLE_MEMBER");
return jdbc.update("insert", params) == 1; //end create
MapSqlParameterSource params = new MapSqlParameterSource(); //start update
params.addValue("enabled", enabled);
params.addValue("username", username);
jdbc.update("update",params); // end update
MapSqlParameterSource params = new MapSqlParameterSource(); //start delete
params.addValue("username", user.getUsername());
jdbc.update("delete",params); //end delete
\end{lstlisting}
\caption{Hibernate-JDBC Code}
\label{fig:jdbchibcode}
\end{figure}

In all tests, Hibernate took less time to perform all actions, though there was not much different between both technologies. However, due to the way Hibernate is configured, it is certainly much easier to develop with. Hibernate required 5 lines of code, shown in Figure~\ref{fig:jdbchibcode}, where JDBC requires 23 lines of code, with 3 different SQL queries, one for INSERT, UPDATE and DELETE. 

By defining and mapping attributes in a database to the class with Hibernate, the DAO classes become much smaller and easier to manage with no impact on performance within the application. In this application, for example, there are more than 70 DAO operations, which would mean 70 or more SQL statements. Use of JDBC would also require the definition of SQL JOINs in relation to both the Timetable and Tournament classes, thereby again increasing complexity within the application. There is more configuration to be undertaken with Hibernate, but the end result is a much easier to manage persistence solution that reduces code complexity.

\subsubsection{Session and Cookie Management}
One benefit of using a framework such as Spring is that the developer does not need to be overly concerned with defining and checking a session in each controller. In a previous project, the developer was responsible to creating and managing the session, as well as ensuring proper access to the site was maintained. Figure~\ref{fig:manualsession} shows how a session must be manually retrieved from a request object within a servlet.

\begin{figure}[H]
\begin{lstlisting}
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
    PrintWriter out = response.getWriter();
    // Print Generic header then check authenitcation and print HTML
    printHeader(out);
    HttpSession currentSession = request.getSession(false);
    checkAuthentication(out, currentSession);
    // Print search form
}
\end{lstlisting}
\caption{Manual Session Creation}
\label{fig:manualsession}
\end{figure}

In the \textit{checkAuthentication()} method, depicted in Figure~\ref{fig:sessionlevel}, the developer must check the session for any attributes that match a certain value, and act accordingly. In this example, the id of a user. The id then needs to checked against a database to ensure that it is a valid id, and to determine what permissions the account has.


\begin{lstlisting}
private void checkAuthentication(PrintWriter out, HttpSession currentSession) {
//Check Authentication
	if (currentSession.getAttribute("ID") == null) {
		//print registration screen
    } else {
        // Use ID and Username to identify users. At this point we know there is a session with an ID, verify it is a valid session
        int intID = (Integer) currentSession.getAttribute("ID");
        String username = (String) currentSession.getAttribute("username");
        if (customerBean.checkCustomerId(intID) == true && customerBean.checkCustomerUsername(username) == true) {
			Customer currentCustomer = customerBean.getCustomer(intID);
			 // Print what customer should see
            } 
		else if (adminBean.checkAdminId(intID) == true && adminBean.checkAdminUsername(username) == true) {
            Admin currentAdmin = adminBean.getAdmin(intID);
			// Print what admin should see   
            }
        }
	}
\end{lstlisting}
\begin{figure}[H]
\caption{Session Authentication based on user level}
\label{fig:sessionlevel}
\end{figure}

An issue with that is that it is reliant on the developer to identify the correct attribute. This is a user defined attribute that may not be unique to the application. Spring manages this through the \textit{security-context.xml} file, which encapsulates security for the application to one file, and the framework itself ensures that the correct session is created for a user. There is no need to specify any of this within the codebase of the application, which again reduces complexity, and minimises the possibility of security leaks being introduced through developer errors.

\section{Architectural Quality}

(Is there a need for this section? Does the preceding section suffice? Evolution support is covered, security can be measured in resisting, identifying and recovering from attacks \cite{bass2003software}

\subsection{Performance}

\subsection{Security}

\subsection{Evolution Support}


Performance, Security and Evolution Support

\section{Functional and Non Functional Requirement Evaluation}

\section{FYP Process and Learnings}

The FYP has been certainly been significant part of the overall college journey. Looking back, and knowing what I know now, there are a number of avenues that I would have liked to explore.

\subsection{Hibernate in Design}
Hibernate was a very powerful framework throughout the development of this project. It was very much a case of learning by doing. Having accumulated experience with the framework, I would like to apply it more in the design stage on an application. One idea that came to me late in the project was the idea of having a top level class that could build the entire application, as depecited in Figure~\ref{fig:toplevel}.

\begin{figure}[H]
\begin{lstlisting}
@Entity
public class WebApplication(){

@ElementCollection
@CollectionTable (name = "tournament", joinColumns=@JoinColumn(name="id"))
private Tournaments tournaments;

@ElementCollection
@CollectionTable (name = "timetable", joinColumns=@JoinColumn(name="id"))
private Timetable timetable;

@ElementCollection
@CollectionTable (name = "news", joinColumns=@JoinColumn(name="id"))
private News news;

@ElementCollection
@CollectionTable (name = "events", joinColumns=@JoinColumn(name="id"))
private Events events;

@ElementCollection
@CollectionTable (name = "users", joinColumns=@JoinColumn(name="id"))
private User users;

public WebApplication(){
	create();
}

private void create(){
	tournaments = getTournaments();
	etc.....
}

//getters and setters

\end{lstlisting}
\caption{'Top Level' Class}
\label{fig:toplevel}
\end{figure}

(This section needs to be rewritten. I'm tired right now so just doing stream of conciousness) 

It would be possible to build the application so that all classes were linked through a hierarchy to one root class. This may impact performance, but it would allow a number of benefits such as ease of deployment, and the ability to take snapshots of the application at any stage.

I also would have like to use Hibernate with more complicated objects rather than just collection classes, but time constraints did not allow this.

\subsection{Tournament Business Logic}

\subsection{Web Services and HTML5}
Other aspects of a web application, such as web services and HTML5 were omitted from the final submission due to time constraints, but are definitely something that I would have an interest in looking at later on.